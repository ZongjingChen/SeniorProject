<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>CustomRobot</title>
<!--    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">-->
</head>
<body>
<!-- The js file should be the result file created by compiler-->
<!--    <script type="module" src="templateFbxLoader.js"></script>-->
<!--    <script type="module" src="../src/testCompiledCode.js"></script>-->
    <script type="module">
        /**
         * Conference: https://threejs.org/examples/webgl_loader_fbx.html
         */
        import * as THREE from 'https://unpkg.com/three@0.126.1/build/three.module.js';
        import {OrbitControls} from 'https://unpkg.com/three@0.126.1/examples/jsm/controls/OrbitControls.js';
        import {FBXLoader} from 'https://unpkg.com/three@0.126.1/examples/jsm/loaders/FBXLoader.js';
        import {SkeletonUtils} from 'https://unpkg.com/three@0.126.1/examples/jsm/utils/SkeletonUtils.js'
        import Stats from 'https://unpkg.com/three@0.126.1/examples/jsm/libs/stats.module.js';
        let camera, scene, renderer, mixer, stats, human;
        // const animationActions = [];
        const HUMAN_MODEL_PATH = '../res/models/Samba Dancing.fbx';
        const ROBOT_MODEL_PATH = '../res/models/';
        const clock = new THREE.Clock();
        const loader = new FBXLoader();
        const DEG_TO_RAD = Math.PI / 180;
        const FPS = 60;
        // Three axes
        const X = new THREE.Vector3(1, 0, 0);
        const Y = new THREE.Vector3(0, 1, 0);
        const Z = new THREE.Vector3(0, 0, 1);


        // Some limitations of human body
        const SHOULDER_TO_ARM_RATIO_X = 0.5;
        const ARM_FRONT_DEGREE_MAX = 180;
        const ARM_BACK_DEGREE_MAX = -60;

        const SHOULDER_TO_ARM_RATIO_Z = 0.5;
        const ARM_OUT_DEGREE_MAX = 180;
        const ARM_IN_DEGREE_MAX = 45;

        const HEAD_ROTATION_MAX = 90;


        init();

        function init() {
            const container = document.createElement( 'div' );
            document.body.appendChild( container );
            camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
            camera.position.set( 100, 200, 300 );
            scene = new THREE.Scene();
            scene.background = new THREE.Color( 0xa0a0a0 );
            // light
            const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444 );
            hemiLight.position.set( 0, 200, 0 );
            scene.add( hemiLight );
            // ground
            const mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2000, 2000 ), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
            mesh.rotation.x = - Math.PI / 2;
            mesh.receiveShadow = true;
            scene.add( mesh );
            // grid
            const grid = new THREE.GridHelper( 2000, 20, 0x000000, 0x000000 );
            grid.material.opacity = 0.2;
            grid.material.transparent = true;
            scene.add( grid );
            // renderer
            renderer = new THREE.WebGLRenderer( { antialias: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.shadowMap.enabled = true;
            container.appendChild( renderer.domElement );
            // mouse control
            const controls = new OrbitControls( camera, renderer.domElement );
            controls.target.set( 0, 100, 0 );
            controls.update();
            window.addEventListener( 'resize', onWindowResize );
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }
            // stats
            stats = new Stats();
            container.appendChild( stats.dom );

            loader.load( HUMAN_MODEL_PATH, function ( object ) {
                mixer = new THREE.AnimationMixer(object);
                // load object and add to scene
                // const model = mixer.clipAction(object.animations[0]);
                // model.play();

                // const animationAction = mixer.clipAction(object.animations[0]);
                // animationAction.reset();
                // animationAction.play();


                // console.log(animationAction);
                // animationAction.reset();
                // animationAction.play();
                scene.add(object);
                human = new Human(object);
                human.playAnimation(object);
            })
        }

        class Human {
            constructor(object){
                // this.loader = loader;
                // this.clock = clock;
                // this.scene = scene;
                // this.camera = camera;
                // this.renderer = renderer;
                this.object = object;
                // this.skeletonHelper = new THREE.SkeletonHelper(object.children[2]);
                // this.skeleton = object.children[2].skeleton;
                // this.leftArm = SkeletonUtils.getBoneByName("mixamorigLeftArm", this.skeleton);
                // this.rightArm = SkeletonUtils.getBoneByName("mixamorigRightArm", this.skeleton);
            }

            playAnimation() {
                /**
                 *  Body parts
                 */
                // TODO: Add all body parts
                const skeleton = this.object.children[2].skeleton;
                const action = mixer.clipAction(this.object.animations[0]);
                console.log(action);

                // praise the sun
                // SkeletonUtils.getBoneByName("mixamorigHead", skeleton).rotation.x = -5 * DEG_TO_RAD;
                // SkeletonUtils.getBoneByName("mixamorigSpine2", skeleton).rotation.x = -15 * DEG_TO_RAD;
                // leftArm.rotation.z = 35 * DEG_TO_RAD;
                // leftArm.rotation.x = -5 * DEG_TO_RAD;
                // rightArm.rotation.z = -35 * DEG_TO_RAD;
                // rightArm.rotation.x = -5 * DEG_TO_RAD;

                // Original state
                {
                    SkeletonUtils.getBoneByName("mixamorigLeftArm", skeleton).rotation.x = -5 * DEG_TO_RAD;
                    SkeletonUtils.getBoneByName("mixamorigLeftArm", skeleton).rotation.z = -85 * DEG_TO_RAD;


                    SkeletonUtils.getBoneByName("mixamorigRightArm", skeleton).rotation.z = 85 * DEG_TO_RAD;
                    SkeletonUtils.getBoneByName("mixamorigRightArm", skeleton).rotation.x = -5 * DEG_TO_RAD;

                    SkeletonUtils.getBoneByName("mixamorigLeftHand", skeleton).rotation.z = -10 * DEG_TO_RAD;
                    SkeletonUtils.getBoneByName("mixamorigRightHand", skeleton).rotation.z = 10 * DEG_TO_RAD;

                    SkeletonUtils.getBoneByName("mixamorigLeftHandThumb1", skeleton).rotation.z = 25 * DEG_TO_RAD;
                    SkeletonUtils.getBoneByName("mixamorigRightHandThumb1", skeleton).rotation.z = -25 * DEG_TO_RAD;
                    SkeletonUtils.getBoneByName("mixamorigRightHandThumb1", skeleton).rotation.x = -10 * DEG_TO_RAD;
                    SkeletonUtils.getBoneByName("mixamorigRightHandThumb1", skeleton).rotation.x = -10 * DEG_TO_RAD;

                    SkeletonUtils.getBoneByName("mixamorigLeftLeg", skeleton).rotation.z = -5 * DEG_TO_RAD;
                    SkeletonUtils.getBoneByName("mixamorigRightLeg", skeleton).rotation.z = 5 * DEG_TO_RAD;

                    // SkeletonUtils.getBoneByName("mixamorigHead", skeleton).rotation.x = 90 * DEG_TO_RAD;
                }

                const prefix = "mixamorig";
                const bodyParts = [
                    "Hips", "Spine", "Spine1", "Spine2", "Neck", "Head",
                    "LeftShoulder", "LeftArm", "LeftForeArm", "LeftHand",
                    "RightShoulder", "RightArm", "RightForeArm", "RightHand",
                    "LeftLeg", "LeftUpLeg", "LeftFoot", "LeftToeBase",
                    "RightLeg", "RightUpLeg", "RightFoot", "RightToeBase"];
                animate();
                console.log(this.object);
                // console.log(skeleton);
                var delta = 0;
                function animate(){
                    requestAnimationFrame(animate);

                    /**
                     * Compiled code should be inserted here.
                     */
                    {
                        riseLeftArmLateral(90, 0, 2);
                        riseRightArmLateral(90, 0, 2);
                        riseLeftArm(90, 2, 4);
                        riseRightArm(90, 2, 4);
                        rotateHeadLeft(30, 2.5, 3);
                        rotateHeadRight(45, 1, 2);
                    }

                    delta += clock.getDelta();

                    renderer.render(scene, camera);
                    mixer.update(1/60);
                    stats.update();

                }

                // Left arm rotate about y axis
                function riseLeftArm(degree, startTime, endTime){
                        // Decide if this action should take place
                        if(startTime <= delta && delta <= endTime){
                            // Make sure the angle is appropriate
                            if(degree <= ARM_BACK_DEGREE_MAX) {
                                degree = ARM_BACK_DEGREE_MAX;
                            }
                            else if(degree >= ARM_FRONT_DEGREE_MAX) {
                                degree = ARM_FRONT_DEGREE_MAX;
                            }
                            // Calculate the degree for arm to change
                            degree = degree / (1 + SHOULDER_TO_ARM_RATIO_X);

                            // Counter clockwise, calculate degree change for one frame
                            degree = - degree / (FPS * (endTime - startTime));
                            rotateY(SkeletonUtils.getBoneByName(prefix + "LeftArm", skeleton), degree);

                            // Add change to shoulder to make the action more vivid.
                            SkeletonUtils.getBoneByName(prefix + "LeftShoulder", skeleton).rotateOnWorldAxis(Y, degree * SHOULDER_TO_ARM_RATIO_X * DEG_TO_RAD);
                            // console.log(- degree * SHOULDER_TO_ARM_RATIO_X * DEG_TO_RAD);
                        }
                    }

                // Right arm rotate about y axis
                function riseRightArm(degree, startTime, endTime){
                        // Decide if this action should take place
                        if(startTime <= delta && delta <= endTime){
                            // Make sure the angle is appropriate
                            if(degree <= ARM_BACK_DEGREE_MAX) {
                                degree = ARM_BACK_DEGREE_MAX;
                            }
                            else if(degree >= ARM_FRONT_DEGREE_MAX) {
                                degree = ARM_FRONT_DEGREE_MAX;
                            }
                            // Calculate the degree for arm to change
                            degree = degree / (1 + SHOULDER_TO_ARM_RATIO_X);

                            // Clockwise
                            degree = degree / (FPS * (endTime - startTime));
                            rotateY(SkeletonUtils.getBoneByName(prefix + "RightArm", skeleton), degree);

                            // Add change to shoulder to make the action more vivid. Counter clockwise.
                            SkeletonUtils.getBoneByName(prefix + "RightShoulder", skeleton).rotateOnWorldAxis(Y, degree * SHOULDER_TO_ARM_RATIO_X * DEG_TO_RAD);
                        }
                    }

                // Left arm rotate about z axis
                function riseLeftArmLateral(degree, startTime, endTime) {
                    // Decide if this action should take place
                    if(startTime <= delta && delta <= endTime){
                        // Make sure the angle is appropriate
                        if(degree >= ARM_OUT_DEGREE_MAX) {
                            degree = ARM_OUT_DEGREE_MAX;
                        }
                        else if(degree <= ARM_IN_DEGREE_MAX) {
                            degree = ARM_IN_DEGREE_MAX;
                        }
                        // Calculate the degree for arm to change
                        degree = degree / (1 + SHOULDER_TO_ARM_RATIO_Z);

                        // Clockwise
                        degree = degree / (FPS * (endTime - startTime));
                        rotateZ(SkeletonUtils.getBoneByName(prefix + "LeftArm", skeleton), degree);

                        // Add change to shoulder to make the action more vivid.
                        // rotateZ(SkeletonUtils.getBoneByName(prefix + "LeftShoulder", skeleton), degree * SHOULDER_TO_ARM_RATIO_Z);
                        SkeletonUtils.getBoneByName(prefix + "LeftShoulder", skeleton).rotateOnWorldAxis(Z, degree * SHOULDER_TO_ARM_RATIO_Z * DEG_TO_RAD);
                    }
                }

                // Right arm rotate about z axis
                function riseRightArmLateral(degree, startTime, endTime) {
                    // Decide if this action should take place
                    if(startTime <= delta && delta <= endTime){
                        // Make sure the angle is appropriate
                        if(degree >= ARM_OUT_DEGREE_MAX) {
                            degree = ARM_OUT_DEGREE_MAX;
                        }
                        else if(degree <= ARM_IN_DEGREE_MAX) {
                            degree = ARM_IN_DEGREE_MAX;
                        }
                        // Calculate the degree for arm to change
                        degree = degree / (1 + SHOULDER_TO_ARM_RATIO_Z);

                        // CounterClockwise
                        degree = - degree / (FPS * (endTime - startTime));
                        rotateZ(SkeletonUtils.getBoneByName(prefix + "RightArm", skeleton), degree);

                        // Add change to shoulder to make the action more vivid.
                        // rotateZ(SkeletonUtils.getBoneByName(prefix + "RightShoulder", skeleton), degree * SHOULDER_TO_ARM_RATIO_Z);
                        SkeletonUtils.getBoneByName(prefix + "RightShoulder", skeleton).rotateOnWorldAxis(Z, degree * SHOULDER_TO_ARM_RATIO_Z * DEG_TO_RAD);
                    }
                }

                function rotateHeadLeft(degree, startTime, endTime) {
                    if(startTime <= delta && delta <= endTime) {
                        if (degree >= HEAD_ROTATION_MAX) {
                            degree = HEAD_ROTATION_MAX;
                        }
                        degree = degree / (FPS * (endTime - startTime));
                        rotateY(SkeletonUtils.getBoneByName(prefix + "Head", skeleton), degree);
                    }
                }

                function rotateHeadRight(degree, startTime, endTime) {
                    if(startTime <= delta && delta <= endTime) {
                        if (degree >= HEAD_ROTATION_MAX) {
                            degree = HEAD_ROTATION_MAX;
                        }
                        degree = - degree / (FPS * (endTime - startTime));
                        rotateY(SkeletonUtils.getBoneByName(prefix + "Head", skeleton), degree);
                    }
                }
                /**
                 * Let a body part rotate about x axis for a degree
                 * @param bodyPart - body part to rotate
                 * @param degree - degree to rotate
                 */
                function rotateX(bodyPart, degree){
                    bodyPart.rotateOnAxis(X, degree * DEG_TO_RAD);
                }

                /**
                 * Let a body part rotate about y axis for a degree
                 * @param bodyPart - body part to rotate
                 * @param degree - degree to rotate
                 */
                function rotateY(bodyPart, degree){
                    // bodyPart.rotation.y += degree * DEG_TO_RAD;
                    bodyPart.rotateOnAxis(Y, degree * DEG_TO_RAD);
                }

                /**
                 * Let a body part rotate about z axis for a degree
                 * @param bodyPart - body part to rotate
                 * @param degree - degree to rotate
                 */
                function rotateZ(bodyPart, degree){
                    // bodyPart.rotation.z += degree * DEG_TO_RAD;
                    bodyPart.rotateOnAxis(Z, degree * DEG_TO_RAD);
                }

                function dance(){
                    if(!action.isRunning()){
                        action.play()
                        console.log("Start play")
                    }
                    // mixer.update(clock.getDelta());
        }

                function stopDance() {
                    if(action.isRunning()) {
                        action.stop();
                        // console.log("stop");
                    }
                }
                // TODO more functions to add
            }
        }

        class Robot{
            // TODO finish Robot Class
        }
    </script>
</body>
</html>
